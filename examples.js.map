{"version":3,"file":"examples.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACp4DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://examples/./node_modules/solid-parameter-controls/dist/Arc.jsx","webpack://examples/./node_modules/solid-parameter-controls/dist/Control.jsx","webpack://examples/./node_modules/solid-parameter-controls/dist/ParameterGestureHandler.jsx","webpack://examples/./node_modules/solid-parameter-controls/dist/ValueInput.jsx","webpack://examples/./node_modules/solid-parameter-controls/dist/index.js","webpack://examples/./node_modules/solid-parameter-controls/dist/range/index.js","webpack://examples/./node_modules/solid-parameter-controls/dist/range/range.js","webpack://examples/./node_modules/solid-js/dist/dev.js","webpack://examples/./node_modules/solid-js/web/dist/dev.js","webpack://examples/webpack/bootstrap","webpack://examples/webpack/runtime/define property getters","webpack://examples/webpack/runtime/hasOwnProperty shorthand","webpack://examples/webpack/runtime/make namespace object","webpack://examples/./index.tsx"],"sourcesContent":["import { template as _$template } from \"solid-js/web\";\nimport { setAttribute as _$setAttribute } from \"solid-js/web\";\nimport { effect as _$effect } from \"solid-js/web\";\nimport { spread as _$spread } from \"solid-js/web\";\n\nconst _tmpl$ = /*#__PURE__*/_$template(`<svg><path fill=\"none\"></path></svg>`, 4, true);\n\nimport { splitProps } from \"solid-js\";\n\nfunction polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n  var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians)\n  };\n}\n\nfunction describeArc(x, y, radius, startAngle, endAngle) {\n  if (startAngle > endAngle) {\n    let tmp = startAngle;\n    startAngle = endAngle;\n    endAngle = tmp;\n  }\n\n  const start = polarToCartesian(x, y, radius, endAngle);\n  const end = polarToCartesian(x, y, radius, startAngle);\n  const largeArcFlag = endAngle - startAngle <= 180 ? \"0\" : \"1\";\n  const d = [\"M\", start.x, start.y, \"A\", radius, radius, 0, largeArcFlag, 0, end.x, end.y].join(\" \");\n  return d;\n}\n/**\n * Produces an SVG path element that renders an arc segment.\n */\n\n\nexport default function Arc(allProps) {\n  const [props, pathProps] = splitProps(allProps, ['x', 'y', 'radius', 'startAngle', 'endAngle']);\n  return (() => {\n    const _el$ = _tmpl$.cloneNode(true);\n\n    _$spread(_el$, pathProps, true, false);\n\n    _$effect(() => _$setAttribute(_el$, \"d\", describeArc(props.x, props.y, props.radius, props.startAngle, props.endAngle)));\n\n    return _el$;\n  })();\n}\n;","import { template as _$template } from \"solid-js/web\";\nimport { delegateEvents as _$delegateEvents } from \"solid-js/web\";\nimport { setAttribute as _$setAttribute } from \"solid-js/web\";\nimport { effect as _$effect } from \"solid-js/web\";\nimport { insert as _$insert } from \"solid-js/web\";\nimport { spread as _$spread } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\n\nconst _tmpl$ = /*#__PURE__*/_$template(`<div tabindex=\"0\" role=\"slider\"></div>`, 2);\n\nimport ParameterGestureHandler from './ParameterGestureHandler';\nimport { splitProps } from 'solid-js';\nexport default function Control(allProps) {\n  const [props, otherProps] = splitProps(allProps, ['children', 'label', 'defaultValue']);\n  const [gestureProps, divProps] = splitProps(otherProps, ['value', 'range', 'onStart', 'onChange']);\n\n  const onGestureStart = e => {\n    if (divProps.onGestureStart instanceof Function) {\n      divProps.onGestureStart(e);\n    }\n\n    const onGestureEnd = e => {\n      if (divProps.onGestureEnd instanceof Function) divProps.onGestureEnd && divProps.onGestureEnd(e);\n      window.removeEventListener('mouseup', onGestureEnd);\n    };\n\n    window.addEventListener('mouseup', onGestureEnd);\n  };\n\n  const resetToDefault = () => {\n    if (props.defaultValue && gestureProps.onChange) gestureProps.onChange(props.defaultValue);\n  };\n\n  return _$createComponent(ParameterGestureHandler, _$mergeProps(gestureProps, {\n    children: ref => (() => {\n      const _el$ = _tmpl$.cloneNode(true);\n\n      _el$.$$click = onGestureStart;\n      _el$.$$touchstart = onGestureStart;\n      _el$.$$mousedown = onGestureStart;\n      _el$.$$dblclick = resetToDefault;\n      const _ref$ = ref;\n      typeof _ref$ === \"function\" ? _ref$(_el$) : ref = _el$;\n\n      _$spread(_el$, divProps, false, true);\n\n      _$insert(_el$, () => props.children);\n\n      _$effect(_p$ => {\n        const _v$ = props.label,\n              _v$2 = gestureProps.range.getStart(),\n              _v$3 = gestureProps.range.getEnd(),\n              _v$4 = gestureProps.value,\n              _v$5 = gestureProps.range.toString(gestureProps.value);\n\n        _v$ !== _p$._v$ && _$setAttribute(_el$, \"aria-label\", _p$._v$ = _v$);\n        _v$2 !== _p$._v$2 && _$setAttribute(_el$, \"aria-valuemin\", _p$._v$2 = _v$2);\n        _v$3 !== _p$._v$3 && _$setAttribute(_el$, \"aria-valuemax\", _p$._v$3 = _v$3);\n        _v$4 !== _p$._v$4 && _$setAttribute(_el$, \"aria-valuenow\", _p$._v$4 = _v$4);\n        _v$5 !== _p$._v$5 && _$setAttribute(_el$, \"aria-valuetext\", _p$._v$5 = _v$5);\n        return _p$;\n      }, {\n        _v$: undefined,\n        _v$2: undefined,\n        _v$3: undefined,\n        _v$4: undefined,\n        _v$5: undefined\n      });\n\n      return _el$;\n    })()\n  }));\n}\n\n_$delegateEvents([\"dblclick\", \"mousedown\", \"touchstart\", \"click\"]);","import { createEffect, onCleanup } from 'solid-js';\nexport default function ParameterGestureHandler(props) {\n  let element = null;\n  let isDragging = false;\n  let valueOnDragStart = 0;\n  let dragValue = 0;\n  let dragStartValue = 0;\n  let value = 0;\n\n  const change = (newValue, snap) => {\n    if (props.onChange) {\n      if (newValue !== value) {\n        newValue = props.range.fromNormalised(newValue);\n\n        if (snap) {\n          newValue = props.range.snap(newValue);\n        }\n\n        props.onChange(newValue);\n      }\n    }\n  };\n\n  const onMouseMove = e => {\n    if (isDragging) {\n      if (props.hideCursor && document.pointerLockElement !== element) {\n        element === null || element === void 0 ? void 0 : element.requestPointerLock();\n      }\n\n      dragValue -= e.movementY;\n      const speedMultiplier = e.shiftKey ? 0.1 : 1;\n      const delta = speedMultiplier * (props.speed || 1) * dragValue / 250;\n      change(valueOnDragStart + delta, !e.shiftKey);\n    }\n  };\n\n  const onMouseUp = () => {\n    if (!isDragging) return;\n\n    if (props.onEnd) {\n      props.onEnd(props.value);\n    }\n\n    isDragging = false;\n\n    if (props.hideCursor) {\n      document.exitPointerLock();\n    }\n  };\n\n  const mouseDown = e => {\n    if (props.onStart) {\n      props.onStart(props.value);\n    }\n\n    valueOnDragStart = value;\n    dragValue = 0;\n    dragStartValue = 0;\n    isDragging = true;\n  };\n\n  const keyUp = () => {\n    if (isDragging) {\n      valueOnDragStart = value;\n      dragValue = dragStartValue;\n    }\n  };\n\n  const wheel = e => {\n    e.stopPropagation();\n    e.preventDefault();\n    change(value - e.deltaY / 2000, false);\n  };\n\n  const touchStart = e => {\n    if (props.onStart) {\n      props.onStart(props.value);\n    }\n\n    valueOnDragStart = value;\n    dragValue = e.touches[0].pageY;\n    isDragging = true;\n  };\n\n  const touchMove = e => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (isDragging) {\n      dragStartValue = e.touches[0].pageY;\n      const delta = (props.speed || 1) * (dragValue - dragStartValue) / 250;\n      change(valueOnDragStart + delta, !e.shiftKey);\n    }\n  };\n\n  const touchEnd = e => {\n    e.preventDefault();\n    e.stopPropagation();\n    isDragging = false;\n\n    if (props.onEnd) {\n      props.onEnd(props.value);\n    }\n  };\n\n  const arrowKeyListener = e => {\n    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key) && props.onChange) {\n      e.preventDefault();\n      e.stopPropagation();\n      const nudge = (['ArrowDown', 'ArrowUp'].includes(e.key) ? 1 : 10) * (['ArrowLeft', 'ArrowDown'].includes(e.key) ? -1 : 1);\n      props.onChange(props.range.nudge(props.value, nudge));\n    }\n  };\n\n  const focus = () => {\n    element === null || element === void 0 ? void 0 : element.addEventListener('keydown', arrowKeyListener);\n  };\n\n  const blur = () => {\n    element === null || element === void 0 ? void 0 : element.removeEventListener('keydown', arrowKeyListener);\n  };\n\n  const registerElement = newElement => {\n    if (!element && newElement) {\n      element = newElement;\n      window.addEventListener('mousemove', onMouseMove);\n      window.addEventListener('mouseup', onMouseUp);\n      element.addEventListener('mousedown', mouseDown);\n      element.addEventListener('wheel', wheel, {\n        passive: false\n      });\n      element.addEventListener('keyup', keyUp);\n      element.addEventListener('focus', focus);\n      element.addEventListener('blur', blur);\n      element.addEventListener('touchstart', touchStart, {\n        cancelable: true\n      });\n      element.addEventListener('touchmove', touchMove, {\n        cancelable: true\n      });\n      element.addEventListener('touchend', touchEnd, {\n        cancelable: true\n      });\n    }\n  };\n\n  onCleanup(() => {\n    window.removeEventListener('mousemove', onMouseMove);\n    window.removeEventListener('mouseup', onMouseUp);\n\n    if (element) {\n      element.removeEventListener('mousedown', mouseDown);\n      element.removeEventListener('wheel', wheel);\n      element.removeEventListener('keyup', keyUp);\n      element.removeEventListener('blur', blur);\n      element.removeEventListener('touchstart', touchStart);\n      element.removeEventListener('touchmove', touchMove);\n      element.removeEventListener('touchend', touchEnd);\n    }\n  });\n  createEffect(() => {\n    value = props.range.toNormalised(props.value);\n  });\n  return props.children(registerElement);\n}","import { template as _$template } from \"solid-js/web\";\nimport { delegateEvents as _$delegateEvents } from \"solid-js/web\";\nimport { effect as _$effect } from \"solid-js/web\";\nimport { spread as _$spread } from \"solid-js/web\";\n\nconst _tmpl$ = /*#__PURE__*/_$template(`<input type=\"text\">`, 1);\n\nimport { splitProps } from \"solid-js\";\nexport default function ValueInput(allProps) {\n  const [props, inputProps] = splitProps(allProps, ['onChange', 'range']);\n  return (() => {\n    const _el$ = _tmpl$.cloneNode(true);\n\n    _el$.$$keydown = e => {\n      if (e.key === 'Enter') {\n        e.preventDefault();\n        e.stopPropagation();\n        const number = e.target.value.replace(/[^0-9\\.\\-]/g, '');\n        const unit = e.target.value.replace(number, '');\n        props.onChange(props.range.fromString(+number, unit));\n      }\n    };\n\n    _el$.$$click = e => e.target.select();\n\n    _$spread(_el$, inputProps, false, false);\n\n    _$effect(() => _el$.value = inputProps.value);\n\n    return _el$;\n  })();\n}\n;\n\n_$delegateEvents([\"click\", \"keydown\"]);","export { default as ParameterGestureHandler } from './ParameterGestureHandler';\nexport { default as Control } from './Control';\nexport { default as Arc } from './Arc';\nexport { default as ValueInput } from './ValueInput';\nexport * from './range';","export { ContinuousRange, ChoiceRange, ToggleRange, limit, Scale } from './range';","/**\n * Clamps `value` to at least `min` and at most `max`.\n */\nexport function limit(value, min, max) {\n  return Math.min(Math.max(min, value), max);\n}\n\nfunction log(n, base) {\n  return Math.log(n) / Math.log(base);\n}\n/**\n * Converts `value` from the range `valueStart`...`valueEnd` to the range `targetStart`...`targetEnd`.\n */\n\n\nfunction toRange(value, valueStart, valueEnd, targetStart, targetEnd) {\n  if (valueEnd === valueStart) {\n    return targetStart;\n  }\n\n  const normalised = (value - valueStart) / (valueEnd - valueStart);\n  return limit(targetStart + normalised * (targetEnd - targetStart), targetStart, targetEnd);\n}\n\nexport var Scale;\n\n(function (Scale) {\n  Scale[Scale[\"Exponential\"] = 0] = \"Exponential\";\n  Scale[Scale[\"Logarithmic\"] = 1] = \"Logarithmic\";\n  Scale[Scale[\"Linear\"] = 2] = \"Linear\";\n})(Scale || (Scale = {}));\n\n;\nexport class ChoiceRange {\n  constructor(choices) {\n    this.choices = choices;\n  }\n\n  toNormalised(value) {\n    return this.choices.findIndex(c => c.value === value) / (this.choices.length - 1);\n  }\n\n  fromNormalised(value) {\n    value = limit(value, 0, 1);\n    return this.choices[Math.round(value * (this.choices.length - 1))].value;\n  }\n\n  fromString(value, unit) {\n    return value;\n  }\n\n  toString(value) {\n    var _a;\n\n    return ((_a = this.choices.find(d => d.value === value)) === null || _a === void 0 ? void 0 : _a.label) || '???';\n  }\n\n  getRandom() {\n    return this.choices[Math.floor(Math.random() * this.choices.length)].value;\n  }\n\n  snap(value) {\n    return value;\n  }\n\n  limit(value) {\n    value = Math.round(value);\n\n    if (this.choices.some(c => c.value === value)) {\n      return value;\n    }\n\n    return -1;\n  }\n\n  nudge(value, steps) {\n    const index = limit(this.choices.findIndex(c => c.value === value) + steps, 0, this.choices.length - 1);\n    return this.choices[index].value;\n  }\n\n  getStart() {\n    return this.choices[0].value;\n  }\n\n  getEnd() {\n    return this.choices[this.choices.length - 1].value;\n  }\n\n  setStart(value) {\n    throw new Error('not applicable');\n  }\n\n  setEnd(value) {\n    throw new Error('not applicable');\n  }\n\n  modulationToString(value) {\n    return `${(100 * value).toPrecision(1)}%`;\n  }\n\n}\nexport class ToggleRange {\n  toNormalised(value) {\n    return value > 0.5 ? 1 : 0;\n  }\n\n  fromNormalised(value) {\n    return value > 0.5 ? 1 : 0;\n  }\n\n  fromString(value, unit) {\n    return value;\n  }\n\n  getRandom() {\n    return Math.random() > 0.5 ? 1 : 0;\n  }\n\n  snap(value) {\n    return value;\n  }\n\n  limit(value) {\n    return limit(Math.round(value), 0, 1);\n  }\n\n  toString(value) {\n    return value > 0.5 ? 'on' : 'off';\n  }\n\n  nudge(value, steps) {\n    if (value === 0 && steps > 0) {\n      return 1;\n    } else if (value === 1 && steps < 0) {\n      return 0;\n    }\n\n    return value;\n  }\n\n  getStart() {\n    return 0;\n  }\n\n  getEnd() {\n    return 1;\n  }\n\n  setStart(value) {\n    throw new Error('not applicable');\n  }\n\n  setEnd(value) {\n    throw new Error('not applicable');\n  }\n\n  modulationToString(value) {\n    return `${(100 * value).toPrecision(1)}%`;\n  }\n\n}\nexport class ContinuousRange {\n  constructor(args) {\n    this.args = {\n      start: 0,\n      end: 1,\n      fromString: (value, unit) => {\n        return value;\n      },\n      toString: value => {\n        return value.toFixed(1);\n      },\n      scale: {\n        type: Scale.Linear\n      }\n    };\n    this.snapMargin = 0.025;\n\n    this.modulationToString = value => {\n      return this.toString(value * (this.args.end - this.args.start));\n    };\n\n    this.args = Object.assign(Object.assign({}, this.args), args);\n    this.interpolatedStart = this.interpolate(this.args.start);\n    this.interpolatedEnd = this.interpolate(this.args.end);\n    this.fromString = this.args.fromString;\n\n    if (this.args.bipolar && this.args.snap && Array.isArray(this.args.snap)) {\n      for (const snap of [...this.args.snap]) {\n        if (snap !== 0) this.args.snap.push(-snap);\n      }\n    }\n\n    if (Array.isArray(this.args.snap)) {\n      this.args.snap.sort();\n    }\n  }\n\n  withStart(newStart) {\n    return new ContinuousRange(Object.assign(Object.assign({}, this.args), {\n      start: newStart\n    }));\n  }\n\n  withEnd(newEnd) {\n    return new ContinuousRange(Object.assign(Object.assign({}, this.args), {\n      end: newEnd\n    }));\n  }\n\n  asBipolar() {\n    return new ContinuousRange(Object.assign(Object.assign({}, this.args), {\n      bipolar: true\n    }));\n  }\n\n  withInterpolation(interpolation) {\n    return new ContinuousRange(Object.assign(Object.assign({}, this.args), {\n      scale: interpolation\n    }));\n  }\n\n  withSnap(values) {\n    return new ContinuousRange(Object.assign(Object.assign({}, this.args), {\n      snap: values\n    }));\n  }\n\n  limitToStep(value) {\n    if (this.args.step) {\n      return Math.round(value / this.args.step) * this.args.step;\n    }\n\n    return value;\n  }\n\n  snap(value) {\n    value = this.toNormalised(value);\n\n    if (Array.isArray(this.args.snap)) {\n      for (const step of this.args.snap) {\n        if (Math.abs(value - this.toNormalised(step)) <= this.snapMargin) return step;\n      }\n    } else if (this.args.snap !== undefined) {\n      return Math.round(this.fromNormalised(value) / this.args.snap) * this.args.snap;\n    }\n\n    return this.fromNormalised(value);\n  }\n\n  getRandom() {\n    return this.fromNormalised(Math.random());\n  }\n\n  limit(value) {\n    if (this.args.bipolar) {\n      return limit(value, -this.args.end, this.args.end);\n    }\n\n    return limit(value, this.args.start, this.args.end);\n  }\n\n  toNormalised(value) {\n    if (this.args.bipolar) {\n      const interpolatedValue = Math.sign(value) * this.interpolate(this.limitToStep(Math.abs(value)));\n      return toRange(interpolatedValue, -this.interpolatedEnd, this.interpolatedEnd, 0, 1);\n    }\n\n    const interpolatedValue = this.interpolate(this.limitToStep(value));\n    return toRange(interpolatedValue, this.interpolatedStart, this.interpolatedEnd, 0, 1);\n  }\n\n  fromNormalised(normalisedValue) {\n    if (this.args.bipolar) {\n      const denormalisedValue = toRange(normalisedValue, 0, 1, -this.interpolatedEnd, this.interpolatedEnd);\n      return this.limitToStep(Math.sign(denormalisedValue) * this.inverseInterpolate(Math.abs(denormalisedValue)));\n    }\n\n    const denormalisedValue = toRange(normalisedValue, 0, 1, this.interpolatedStart, this.interpolatedEnd);\n    return this.limitToStep(this.inverseInterpolate(denormalisedValue));\n  }\n\n  interpolate(value) {\n    switch (this.args.scale.type) {\n      case Scale.Exponential:\n        return Math.pow(value, 1 / (this.args.scale.exp || 1));\n\n      case Scale.Logarithmic:\n        return log(value, this.args.scale.base);\n    }\n\n    return value;\n  }\n\n  inverseInterpolate(value) {\n    switch (this.args.scale.type) {\n      case Scale.Exponential:\n        return Math.pow(value, this.args.scale.exp || 1);\n\n      case Scale.Logarithmic:\n        return Math.pow(this.args.scale.base, value);\n    }\n\n    return value;\n  }\n\n  asModulationRange() {\n    const span = Math.abs(this.args.end - this.args.start);\n    return new ContinuousRange(Object.assign(Object.assign({}, this.args), {\n      start: 0,\n      bipolar: true,\n      end: span\n    }));\n  }\n\n  toString(value) {\n    return this.args.toString(value);\n  }\n\n  nudge(value, steps) {\n    if (this.args.step) {\n      return this.limitToStep(value + steps);\n    }\n\n    return this.fromNormalised(this.toNormalised(value) + steps * 0.01);\n  }\n\n  getStart() {\n    return this.args.start;\n  }\n\n  getEnd() {\n    return this.args.end;\n  }\n\n  setStart(value) {\n    this.args.start = value;\n    this.interpolatedStart = this.interpolate(this.args.start);\n  }\n\n  setEnd(value) {\n    this.args.end = value;\n    this.interpolatedEnd = this.interpolate(this.args.end);\n  }\n\n}","let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\n\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n\n  scheduleCallback = () => port.postMessage(null);\n\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\n\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n\n    return m;\n  }\n\n  taskQueue.splice(findIndex(), 0, task);\n}\n\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n\n  return newTask;\n}\n\nfunction cancelCallback(task) {\n  task.fn = null;\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n\n    const callback = currentTask.fn;\n\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n\n    currentTask = taskQueue[0] || null;\n  }\n\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\n\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\n\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\n\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nlet rootCount = 0;\n\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        unowned = fn.length === 0,\n        root = unowned && !\"_SOLID_DEV_\" ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  },\n        updateFn = unowned ? () => fn(() => {\n    throw new Error(\"Dispose method must be an explicit argument to createRoot function\");\n  }) : () => fn(() => cleanNode(root));\n  if (owner) root.name = `${owner.name}-r${rootCount++}`;\n  Owner = root;\n  Listener = null;\n\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\n\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  if (!options.internal) s.name = registerGraph(options.name || hashValue(value), s);\n\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n\n    return writeSignal(s, value);\n  };\n\n  return [readSignal.bind(s), setter];\n}\n\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE, options);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\n\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE, options);\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\n\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE, options),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\n\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0, options),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\n\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0, options);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n\n  return readSignal.bind(c);\n}\n\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n\n  options || (options = {});\n  const contexts = new Set(),\n        [value, setValue] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      resolved = (\"initialValue\" in options),\n      dynamic = typeof source === \"function\" && createMemo(source);\n\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if (initP && (p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = null;\n      setError(err = e);\n\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n\n    return v;\n  }\n\n  function completeLoad(v) {\n    batch(() => {\n      setValue(() => v);\n      setLoading(false);\n\n      for (const c of contexts.keys()) c.decrement();\n\n      contexts.clear();\n    });\n  }\n\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = value();\n    if (err) throw err;\n\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n\n    return v;\n  }\n\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n\n    },\n    error: {\n      get() {\n        return error();\n      }\n\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        if (err) throw err;\n        return value();\n      }\n\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\n\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\n\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n\n    for (const key of subs.keys()) if (fn(key, v) !== fn(key, p)) {\n      const l = subs.get(key);\n\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n\n    return v;\n  }, undefined, true, STALE, options);\n  updateComputation(node);\n  return key => {\n    let listener;\n\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\n\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\n\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\n\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n\n    if (isArray) {\n      input = Array(deps.length);\n\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\n\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\n\nfunction onCleanup(fn) {\n  if (Owner === null) console.warn(\"cleanups created outside a `createRoot` or `render` will never be run\");else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\n\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) console.warn(\"error handlers created outside a `createRoot` or `render` will never be run\");else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\n\nfunction getListener() {\n  return Listener;\n}\n\nfunction getOwner() {\n  return Owner;\n}\n\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\n\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\n\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n\n    batch(fn);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\n\nfunction useTransition() {\n  return [transPending, startTransition];\n}\n\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\n\nfunction devComponent(Comp, props) {\n  const c = createComputation(() => untrack(() => {\n    Object.assign(Comp, {\n      [$DEVCOMP]: true\n    });\n    return Comp(props);\n  }), undefined, true);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.state = 0;\n  c.componentName = Comp.name;\n  updateComputation(c);\n  return c.tValue !== undefined ? c.tValue : c.value;\n}\n\nfunction hashValue(v) {\n  const s = new Set();\n  return `s${typeof v === \"string\" ? hash(v) : hash(JSON.stringify(v, (k, v) => {\n    if (typeof v === \"object\" && v != null) {\n      if (s.has(v)) return;\n      s.add(v);\n      const keys = Object.keys(v);\n      const desc = Object.getOwnPropertyDescriptors(v);\n      const newDesc = keys.reduce((memo, key) => {\n        const value = desc[key];\n        if (!value.get) memo[key] = value;\n        return memo;\n      }, {});\n      v = Object.create({}, newDesc);\n    }\n\n    if (typeof v === \"bigint\") {\n      return `${v.toString()}n`;\n    }\n\n    return v;\n  }) || \"\")}`;\n}\n\nfunction registerGraph(name, value) {\n  let tryName = name;\n\n  if (Owner) {\n    let i = 0;\n    Owner.sourceMap || (Owner.sourceMap = {});\n\n    while (Owner.sourceMap[tryName]) tryName = `${name}-${++i}`;\n\n    Owner.sourceMap[tryName] = value;\n  }\n\n  return tryName;\n}\n\nfunction serializeGraph(owner) {\n  owner || (owner = Owner);\n  if (!owner) return {};\n  return { ...serializeValues(owner.sourceMap),\n    ...(owner.owned ? serializeChildren(owner) : {})\n  };\n}\n\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\n\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\n\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\n\nlet SuspenseContext;\n\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\n\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\n\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);\n    Updates = updates;\n  }\n\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\n\nfunction writeSignal(node, value, isComp) {\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n\n  let TransitionRunning = false;\n\n  if (Transition) {\n    TransitionRunning = Transition.running;\n\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n\n        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n          if (o.pure) Updates.push(o);else Effects.push(o);\n          if (o.observers) markDownstream(o);\n        }\n\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (\"_SOLID_DEV_\") throw new Error(\"Potential Infinite Loop Detected.\");\n        throw new Error();\n      }\n    }, false);\n  }\n\n  return value;\n}\n\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n\n  Listener = listener;\n  Owner = owner;\n}\n\nfunction runComputation(node, value, time) {\n  let nextValue;\n\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n\n    node.updatedAt = time;\n  }\n}\n\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n\n  if (Owner === null) console.warn(\"computations created outside a `createRoot` or `render` will never be disposed\");else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n\n    c.name = options && options.name || `${Owner.name || \"c\"}-${(Owner.owned || Owner.tOwned).length}`;\n  }\n\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n\n  return c;\n}\n\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookUpstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\n\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    handleError(err);\n  } finally {\n    Updates = null;\n    if (!wait) Effects = null;\n  }\n}\n\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n\n  if (wait) return;\n  let res;\n\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n\n    const sources = Transition.sources;\n    res = Transition.resolve;\n    Effects.forEach(e => {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    });\n    Transition = null;\n    batch(() => {\n      sources.forEach(v => {\n        v.value = v.tValue;\n\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      });\n      setTransPending(false);\n    });\n  }\n\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n    globalThis._$afterUpdate && globalThis._$afterUpdate();\n  }\n  if (res) res();\n}\n\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\n\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\n\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n\n  if (sharedConfig.context) setHydrateContext();\n  const resume = queue.length;\n\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\n\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\n\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\n\nfunction cleanNode(node) {\n  let i;\n\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n\n      delete node.tOwned;\n    }\n\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n\n    node.owned = null;\n  }\n\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n\n    node.cleanups = null;\n  }\n\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n  delete node.sourceMap;\n}\n\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\n\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  fns.forEach(f => f(err));\n}\n\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\n\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n\n  if (Array.isArray(children)) {\n    const results = [];\n\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n\n    return results;\n  }\n\n  return children;\n}\n\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\n\nfunction hash(s) {\n  for (var i = 0, h = 9; i < s.length;) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n\n  return `${h ^ h >>> 9}`;\n}\n\nfunction serializeValues(sources = {}) {\n  const k = Object.keys(sources);\n  const result = {};\n\n  for (let i = 0; i < k.length; i++) {\n    const key = k[i];\n    result[key] = sources[key].value;\n  }\n\n  return result;\n}\n\nfunction serializeChildren(root) {\n  const result = {};\n\n  for (let i = 0, len = root.owned.length; i < len; i++) {\n    const node = root.owned[i];\n    result[node.componentName ? `${node.componentName}:${node.name}` : node.name] = { ...serializeValues(node.sourceMap),\n      ...(node.owned ? serializeChildren(node) : {})\n    };\n  }\n\n  return result;\n}\n\nfunction getSymbol() {\n  const SymbolCopy = Symbol;\n  return SymbolCopy.observable || \"@@observable\";\n}\n\nfunction observable(input) {\n  const $$observable = getSymbol();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n\n      const handler = \"next\" in observer ? observer.next.bind(observer) : observer;\n      let complete = false;\n      createComputed(() => {\n        if (complete) return;\n        const v = input();\n        untrack(() => handler(v));\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n\n      };\n    },\n\n    [$$observable]() {\n      return this;\n    }\n\n  };\n}\n\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\n\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\n\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n\n      return mapped;\n    });\n\n    function mapper(disposer) {\n      disposers[j] = disposer;\n\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n\n      return mapFn(newItems[j]);\n    }\n  };\n}\n\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n\n        return mapped;\n      }\n\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\n\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\n\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = devComponent(Comp, props || {});\n      setHydrateContext(c);\n      return r;\n    }\n  }\n\n  return devComponent(Comp, props || {});\n}\n\nfunction trueFn() {\n  return true;\n}\n\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n\n  has(_, property) {\n    return _.has(property);\n  },\n\n  set: trueFn,\n  deleteProperty: trueFn,\n\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n\n      get() {\n        return _.get(property);\n      },\n\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n\n  ownKeys(_) {\n    return _.keys();\n  }\n\n};\n\nfunction resolveSource(s) {\n  return (s = typeof s === \"function\" ? s() : s) == null ? {} : s;\n}\n\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n\n      return false;\n    },\n\n    keys() {\n      const keys = [];\n\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n\n      return [...new Set(keys)];\n    }\n\n  }, propTraps);\n}\n\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n\n        set() {\n          return true;\n        }\n\n      });\n    }\n\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n\n  }, propTraps));\n  return res;\n}\n\nfunction lazy(fn) {\n  let comp;\n  let p;\n\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      Object.assign(Comp, {\n        [$DEVCOMP]: true\n      });\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n\n  return wrap;\n}\n\nlet counter = 0;\n\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\n\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\n\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n\n    return props.fallback;\n  });\n}\n\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\n\nfunction Match(props) {\n  return props;\n}\n\nlet Errors;\nconst NoErrors = {};\n\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn(NoErrors));\n}\n\nfunction ErrorBoundary(props) {\n  let err = NoErrors;\n\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count) || NoErrors;\n  }\n\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n\n    if ((e = errored()) !== NoErrors) {\n      const f = props.fallback;\n      if (typeof f !== \"function\" || f.length == 0) console.error(e);\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(NoErrors))) : f;\n    }\n\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\n\nfunction SuspenseList(props) {\n  let index = 0,\n      suspenseSetter,\n      showContent,\n      showFallback;\n  const listContext = useContext(SuspenseListContext);\n\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n\n  const registry = [],\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        registry[index++] = {\n          inFallback,\n          showContent,\n          showFallback\n        };\n        return [showingContent, showingFallback];\n      }\n    },\n\n    get children() {\n      return props.children;\n    }\n\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reverse = reveal === \"backwards\";\n\n    if (reveal === \"together\") {\n      const all = registry.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      registry.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n\n    let stop = false;\n\n    for (let i = 0, len = registry.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = registry[n].inFallback();\n\n      if (!stop && !s) {\n        registry[n].showContent(visibleContent);\n        registry[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n\n        if (!tail || next && tail === \"collapsed\") {\n          registry[n].showFallback(visibleFallback);\n        } else registry[n].showFallback(false);\n\n        stop = true;\n        registry[n].showContent(next);\n      }\n    }\n\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\n\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if ((error = err) || sharedConfig.done) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    }\n  }\n\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n\n  });\n}\n\nlet DEV;\n{\n  DEV = {\n    writeSignal,\n    serializeGraph,\n    registerGraph,\n    hashValue\n  };\n}\n\nif (globalThis) {\n  if (!globalThis.Solid$$) globalThis.Solid$$ = true;else console.warn(\"You appear to have multiple instances of Solid. This can lead to unexpected behavior.\");\n}\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };","import { createMemo, createRoot, createRenderEffect, sharedConfig, enableHydration, createSignal, onCleanup, splitProps, $DEVCOMP, untrack } from 'solid-js';\nexport { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, createRenderEffect as effect, getOwner, mergeProps } from 'solid-js';\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = /*#__PURE__*/new Set([\"className\", \"value\", \"readOnly\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = /*#__PURE__*/new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = {\n  className: \"class\",\n  htmlFor: \"for\"\n};\nconst PropAliases = {\n  class: \"className\",\n  formnovalidate: \"formNoValidate\",\n  ismap: \"isMap\",\n  nomodule: \"noModule\",\n  playsinline: \"playsInline\",\n  readonly: \"readOnly\"\n};\nconst DelegatedEvents = /*#__PURE__*/new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = /*#__PURE__*/new Set([\"altGlyph\", \"altGlyphDef\", \"altGlyphItem\", \"animate\", \"animateColor\", \"animateMotion\", \"animateTransform\", \"circle\", \"clipPath\", \"color-profile\", \"cursor\", \"defs\", \"desc\", \"ellipse\", \"feBlend\", \"feColorMatrix\", \"feComponentTransfer\", \"feComposite\", \"feConvolveMatrix\", \"feDiffuseLighting\", \"feDisplacementMap\", \"feDistantLight\", \"feFlood\", \"feFuncA\", \"feFuncB\", \"feFuncG\", \"feFuncR\", \"feGaussianBlur\", \"feImage\", \"feMerge\", \"feMergeNode\", \"feMorphology\", \"feOffset\", \"fePointLight\", \"feSpecularLighting\", \"feSpotLight\", \"feTile\", \"feTurbulence\", \"filter\", \"font\", \"font-face\", \"font-face-format\", \"font-face-name\", \"font-face-src\", \"font-face-uri\", \"foreignObject\", \"g\", \"glyph\", \"glyphRef\", \"hkern\", \"image\", \"line\", \"linearGradient\", \"marker\", \"mask\", \"metadata\", \"missing-glyph\", \"mpath\", \"path\", \"pattern\", \"polygon\", \"polyline\", \"radialGradient\", \"rect\", \"set\", \"stop\", \"svg\", \"switch\", \"symbol\", \"text\", \"textPath\", \"tref\", \"tspan\", \"use\", \"view\", \"vkern\"]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nconst DOMElements = /*#__PURE__*/new Set([\"html\", \"base\", \"head\", \"link\", \"meta\", \"style\", \"title\", \"body\", \"address\", \"article\", \"aside\", \"footer\", \"header\", \"main\", \"nav\", \"section\", \"body\", \"blockquote\", \"dd\", \"div\", \"dl\", \"dt\", \"figcaption\", \"figure\", \"hr\", \"li\", \"ol\", \"p\", \"pre\", \"ul\", \"a\", \"abbr\", \"b\", \"bdi\", \"bdo\", \"br\", \"cite\", \"code\", \"data\", \"dfn\", \"em\", \"i\", \"kbd\", \"mark\", \"q\", \"rp\", \"rt\", \"ruby\", \"s\", \"samp\", \"small\", \"span\", \"strong\", \"sub\", \"sup\", \"time\", \"u\", \"var\", \"wbr\", \"area\", \"audio\", \"img\", \"map\", \"track\", \"video\", \"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"portal\", \"source\", \"svg\", \"math\", \"canvas\", \"noscript\", \"script\", \"del\", \"ins\", \"caption\", \"col\", \"colgroup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"button\", \"datalist\", \"fieldset\", \"form\", \"input\", \"label\", \"legend\", \"meter\", \"optgroup\", \"option\", \"output\", \"progress\", \"select\", \"textarea\", \"details\", \"dialog\", \"menu\", \"summary\", \"details\", \"slot\", \"template\", \"acronym\", \"applet\", \"basefont\", \"bgsound\", \"big\", \"blink\", \"center\", \"content\", \"dir\", \"font\", \"frame\", \"frameset\", \"hgroup\", \"image\", \"keygen\", \"marquee\", \"menuitem\", \"nobr\", \"noembed\", \"noframes\", \"plaintext\", \"rb\", \"rtc\", \"shadow\", \"spacer\", \"strike\", \"tt\", \"xmp\", \"a\", \"abbr\", \"acronym\", \"address\", \"applet\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"basefont\", \"bdi\", \"bdo\", \"bgsound\", \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\", \"col\", \"colgroup\", \"content\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"frame\", \"frameset\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"image\", \"img\", \"input\", \"ins\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"nav\", \"nobr\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"plaintext\", \"portal\", \"pre\", \"progress\", \"q\", \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"shadow\", \"slot\", \"small\", \"source\", \"spacer\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"xmp\", \"input\"]);\n\nfunction memo(fn, equals) {\n  return createMemo(fn, undefined, !equals ? {\n    equals\n  } : undefined);\n}\n\nfunction reconcileArrays(parentNode, a, b) {\n  let bLength = b.length,\n      aEnd = a.length,\n      bEnd = bLength,\n      aStart = 0,\n      bStart = 0,\n      after = a[aEnd - 1].nextSibling,\n      map = null;\n\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n\n    while (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n\n      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a[aStart])) a[aStart].remove();\n        aStart++;\n      }\n    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      const node = a[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n\n        while (i < bEnd) map.set(b[i], i++);\n      }\n\n      const index = map.get(a[aStart]);\n\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i = aStart,\n              sequence = 1,\n              t;\n\n          while (++i < aEnd && i < bEnd) {\n            if ((t = map.get(a[i])) == null || t !== index + sequence) break;\n            sequence++;\n          }\n\n          if (sequence > index - bStart) {\n            const node = a[aStart];\n\n            while (bStart < index) parentNode.insertBefore(b[bStart++], node);\n          } else parentNode.replaceChild(b[bStart++], a[aStart++]);\n        } else aStart++;\n      } else a[aStart++].remove();\n    }\n  }\n}\n\nconst $$EVENTS = \"_$DX_DELEGATE\";\n\nfunction render(code, element, init) {\n  let disposer;\n  createRoot(dispose => {\n    disposer = dispose;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : undefined, init);\n  });\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\n\nfunction template(html, check, isSVG) {\n  const t = document.createElement(\"template\");\n  t.innerHTML = html;\n  if (check && t.innerHTML.split(\"<\").length - 1 !== check) throw `The browser resolved template HTML does not match JSX input:\\n${t.innerHTML}\\n\\n${html}. Is your HTML properly formed?`;\n  let node = t.content.firstChild;\n  if (isSVG) node = node.firstChild;\n  return node;\n}\n\nfunction delegateEvents(eventNames, document = window.document) {\n  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());\n\n  for (let i = 0, l = eventNames.length; i < l; i++) {\n    const name = eventNames[i];\n\n    if (!e.has(name)) {\n      e.add(name);\n      document.addEventListener(name, eventHandler);\n    }\n  }\n}\n\nfunction clearDelegatedEvents(document = window.document) {\n  if (document[$$EVENTS]) {\n    for (let name of document[$$EVENTS].keys()) document.removeEventListener(name, eventHandler);\n\n    delete document[$$EVENTS];\n  }\n}\n\nfunction setAttribute(node, name, value) {\n  if (value == null) node.removeAttribute(name);else node.setAttribute(name, value);\n}\n\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null) node.removeAttributeNS(namespace, name);else node.setAttributeNS(namespace, name, value);\n}\n\nfunction className(node, value) {\n  if (value == null) node.removeAttribute(\"class\");else node.className = value;\n}\n\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, handler[0] = e => handlerFn.call(node, handler[1], e));\n  } else node.addEventListener(name, handler);\n}\n\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}),\n        prevKeys = Object.keys(prev);\n  let i, len;\n\n  for (i = 0, len = prevKeys.length; i < len; i++) {\n    const key = prevKeys[i];\n    if (!key || key === \"undefined\" || value[key]) continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n\n  for (i = 0, len = classKeys.length; i < len; i++) {\n    const key = classKeys[i],\n          classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue) continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n\n  return prev;\n}\n\nfunction style(node, value, prev = {}) {\n  const nodeStyle = node.style;\n  const prevString = typeof prev === \"string\";\n  if (value == null && prevString || typeof value === \"string\") return nodeStyle.cssText = value;\n  prevString && (nodeStyle.cssText = undefined, prev = {});\n  value || (value = {});\n  let v, s;\n\n  for (s in prev) {\n    value[s] == null && nodeStyle.removeProperty(s);\n    delete prev[s];\n  }\n\n  for (s in value) {\n    v = value[s];\n\n    if (v !== prev[s]) {\n      nodeStyle.setProperty(s, v);\n      prev[s] = v;\n    }\n  }\n\n  return prev;\n}\n\nfunction spread(node, accessor, isSVG, skipChildren) {\n  if (typeof accessor === \"function\") {\n    createRenderEffect(current => spreadExpression(node, accessor(), current, isSVG, skipChildren));\n  } else spreadExpression(node, accessor, undefined, isSVG, skipChildren);\n}\n\nfunction dynamicProperty(props, key) {\n  const src = props[key];\n  Object.defineProperty(props, key, {\n    get() {\n      return src();\n    },\n\n    enumerable: true\n  });\n  return props;\n}\n\nfunction innerHTML(parent, content) {\n  !sharedConfig.context && (parent.innerHTML = content);\n}\n\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== undefined && !initial) initial = [];\n  if (typeof accessor !== \"function\") return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);\n}\n\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\") continue;\n      assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);\n    }\n  }\n\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren) insertExpression(node, props.children);\n      continue;\n    }\n\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);\n  }\n}\n\nfunction hydrate$1(code, element, options = {}) {\n  sharedConfig.completed = globalThis._$HY.completed;\n  sharedConfig.events = globalThis._$HY.events;\n  sharedConfig.load = globalThis._$HY.load;\n\n  sharedConfig.gather = root => gatherHydratable(element, root);\n\n  sharedConfig.registry = new Map();\n  sharedConfig.context = {\n    id: options.renderId || \"\",\n    count: 0\n  };\n  gatherHydratable(element, options.renderId);\n  const dispose = render(code, element, [...element.childNodes]);\n  sharedConfig.context = null;\n  return dispose;\n}\n\nfunction getNextElement(template) {\n  let node, key;\n\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    return template.cloneNode(true);\n  }\n\n  if (sharedConfig.completed) sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\n\nfunction getNextMatch(el, nodeName) {\n  while (el && el.localName !== nodeName) el = el.nextSibling;\n\n  return el;\n}\n\nfunction getNextMarker(start) {\n  let end = start,\n      count = 0,\n      current = [];\n\n  if (sharedConfig.context) {\n    while (end) {\n      if (end.nodeType === 8) {\n        const v = end.nodeValue;\n        if (v === \"#\") count++;else if (v === \"/\") {\n          if (count === 0) return [end, current];\n          count--;\n        }\n      }\n\n      current.push(end);\n      end = end.nextSibling;\n    }\n  }\n\n  return [end, current];\n}\n\nfunction runHydrationEvents() {\n  if (sharedConfig.events && !sharedConfig.events.queued) {\n    queueMicrotask(() => {\n      const {\n        completed,\n        events\n      } = sharedConfig;\n      events.queued = false;\n\n      while (events.length) {\n        const [el, e] = events[0];\n        if (!completed.has(el)) return;\n        eventHandler(e);\n        events.shift();\n      }\n    });\n    sharedConfig.events.queued = true;\n  }\n}\n\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\n\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n\n  for (let i = 0, nameLen = classNames.length; i < nameLen; i++) node.classList.toggle(classNames[i], value);\n}\n\nfunction assignProp(node, prop, value, prev, isSVG, skipRef) {\n  let isCE, isProp, isChildProp;\n  if (prop === \"style\") return style(node, value, prev);\n  if (prop === \"classList\") return classList(node, value, prev);\n  if (value === prev) return prev;\n\n  if (prop === \"ref\") {\n    if (!skipRef) {\n      value(node);\n    }\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e = prop.slice(3);\n    prev && node.removeEventListener(e, prev);\n    value && node.addEventListener(e, value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e = prop.slice(10);\n    prev && node.removeEventListener(e, prev, true);\n    value && node.addEventListener(e, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n\n    if (!delegate && prev) {\n      const h = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h);\n    }\n\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (PropAliases[prop] || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\"))) {\n    if (prop === \"class\" || prop === \"className\") className(node, value);else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;else node[PropAliases[prop] || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns) setAttributeNS(node, ns, prop, value);else setAttribute(node, Aliases[prop] || prop, value);\n  }\n\n  return value;\n}\n\nfunction eventHandler(e) {\n  const key = `$$${e.type}`;\n  let node = e.composedPath && e.composedPath()[0] || e.target;\n\n  if (e.target !== node) {\n    Object.defineProperty(e, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n\n  Object.defineProperty(e, \"currentTarget\", {\n    configurable: true,\n\n    get() {\n      return node || document;\n    }\n\n  });\n\n  if (sharedConfig.registry && !sharedConfig.done) {\n    sharedConfig.done = true;\n    document.querySelectorAll(\"[id^=pl-]\").forEach(elem => elem.remove());\n  }\n\n  while (node !== null) {\n    const handler = node[key];\n\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);\n      if (e.cancelBubble) return;\n    }\n\n    node = node.host && node.host !== node && node.host instanceof Node ? node.host : node.parentNode;\n  }\n}\n\nfunction spreadExpression(node, props, prevProps = {}, isSVG, skipChildren) {\n  props || (props = {});\n\n  if (!skipChildren && \"children\" in props) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n\n  props.ref && props.ref(node);\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\n\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context && !current) current = [...parent.childNodes];\n\n  while (typeof current === \"function\") current = current();\n\n  if (value === current) return current;\n  const t = typeof value,\n        multi = marker !== undefined;\n  parent = multi && current[0] && current[0].parentNode || parent;\n\n  if (t === \"string\" || t === \"number\") {\n    if (sharedConfig.context) return current;\n    if (t === \"number\") value = value.toString();\n\n    if (multi) {\n      let node = current[0];\n\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else node = document.createTextNode(value);\n\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    }\n  } else if (value == null || t === \"boolean\") {\n    if (sharedConfig.context) return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n\n      while (typeof v === \"function\") v = v();\n\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n\n    if (normalizeIncomingArray(array, value, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n\n    if (sharedConfig.context) {\n      for (let i = 0; i < array.length; i++) {\n        if (array[i].parentNode) return current = array;\n      }\n    }\n\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi) return current;\n    } else if (Array.isArray(current)) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context && value.parentNode) return current = multi ? [value] : value;\n\n    if (Array.isArray(current)) {\n      if (multi) return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else parent.replaceChild(value, parent.firstChild);\n\n    current = value;\n  } else console.warn(`Unrecognized value. Skipped inserting`, value);\n\n  return current;\n}\n\nfunction normalizeIncomingArray(normalized, array, unwrap) {\n  let dynamic = false;\n\n  for (let i = 0, len = array.length; i < len; i++) {\n    let item = array[i],\n        t;\n\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ;else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item) || dynamic;\n    } else if ((t = typeof item) === \"string\") {\n      normalized.push(document.createTextNode(item));\n    } else if (t === \"function\") {\n      if (unwrap) {\n        while (typeof item === \"function\") item = item();\n\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else normalized.push(document.createTextNode(item.toString()));\n  }\n\n  return dynamic;\n}\n\nfunction appendNodes(parent, array, marker) {\n  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);\n}\n\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === undefined) return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n\n  if (current.length) {\n    let inserted = false;\n\n    for (let i = current.length - 1; i >= 0; i--) {\n      const el = current[i];\n\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i) isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);else isParent && el.remove();\n      } else inserted = true;\n    }\n  } else parent.insertBefore(node, marker);\n\n  return [node];\n}\n\nfunction gatherHydratable(element, root) {\n  const templates = element.querySelectorAll(`*[data-hk]`);\n\n  for (let i = 0; i < templates.length; i++) {\n    const node = templates[i];\n    const key = node.getAttribute(\"data-hk\");\n    if ((!root || key.startsWith(root)) && !sharedConfig.registry.has(key)) sharedConfig.registry.set(key, node);\n  }\n}\n\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\n\nfunction Assets() {\n  return;\n}\n\nfunction NoHydration(props) {\n  return sharedConfig.context ? undefined : props.children;\n}\n\nfunction throwInBrowser(func) {\n  const err = new Error(`${func.name} is not supported in the browser, returning undefined`);\n  console.error(err);\n}\n\nfunction renderToString(fn, options) {\n  throwInBrowser(renderToString);\n}\n\nfunction renderToStringAsync(fn, options) {\n  throwInBrowser(renderToStringAsync);\n}\n\nfunction renderToStream(fn, options) {\n  throwInBrowser(renderToStream);\n}\n\nfunction ssr(template, ...nodes) {}\n\nfunction resolveSSRNode(node) {}\n\nfunction ssrClassList(value) {}\n\nfunction ssrStyle(value) {}\n\nfunction ssrSpread(accessor) {}\n\nfunction ssrAttribute(key, value) {}\n\nfunction ssrHydrationKey() {}\n\nfunction escape(html) {}\n\nfunction generateHydrationScript() {}\n\nconst isServer = false;\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\n\nconst hydrate = (...args) => {\n  enableHydration();\n  return hydrate$1(...args);\n};\n\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props,\n        marker = document.createTextNode(\"\"),\n        mount = props.mount || document.body;\n\n  function renderPortal() {\n    if (sharedConfig.context) {\n      const [s, set] = createSignal(false);\n      queueMicrotask(() => set(true));\n      return () => s() && props.children;\n    } else return () => props.children;\n  }\n\n  if (mount instanceof HTMLHeadElement) {\n    const [clean, setClean] = createSignal(false);\n\n    const cleanup = () => setClean(true);\n\n    createRoot(dispose => insert(mount, () => !clean() ? renderPortal()() : dispose(), null));\n    onCleanup(() => {\n      if (sharedConfig.context) queueMicrotask(cleanup);else cleanup();\n    });\n  } else {\n    const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG),\n          renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n      mode: \"open\"\n    }) : container;\n    Object.defineProperty(container, \"host\", {\n      get() {\n        return marker.parentNode;\n      }\n\n    });\n    insert(renderRoot, renderPortal());\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    onCleanup(() => mount.removeChild(container));\n  }\n\n  return marker;\n}\n\nfunction Dynamic(props) {\n  const [p, others] = splitProps(props, [\"component\"]);\n  const cached = createMemo(() => p.component);\n  return createMemo(() => {\n    const component = cached();\n\n    switch (typeof component) {\n      case \"function\":\n        Object.assign(component, {\n          [$DEVCOMP]: true\n        });\n        return untrack(() => component(others));\n\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\n\nexport { Aliases, Assets, ChildProperties, DOMElements, DelegatedEvents, Dynamic, Assets as HydrationScript, NoHydration, Portal, PropAliases, Properties, SVGElements, SVGNamespace, addEventListener, assign, classList, className, clearDelegatedEvents, delegateEvents, dynamicProperty, escape, generateHydrationScript, getHydrationKey, getNextElement, getNextMarker, getNextMatch, hydrate, innerHTML, insert, isServer, memo, render, renderToStream, renderToString, renderToStringAsync, resolveSSRNode, runHydrationEvents, setAttribute, setAttributeNS, spread, ssr, ssrAttribute, ssrClassList, ssrHydrationKey, ssrSpread, ssrStyle, style, template };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { template as _$template } from \"solid-js/web\";\nimport { mergeProps as _$mergeProps } from \"solid-js/web\";\nimport { insert as _$insert } from \"solid-js/web\";\nimport { createComponent as _$createComponent } from \"solid-js/web\";\n\nconst _tmpl$ = /*#__PURE__*/_$template(`<svg viewBox=\"0 0 100 100\"></svg>`, 2),\n      _tmpl$2 = /*#__PURE__*/_$template(`<h1>solid-parameter-controls examples</h1>`, 2);\n\nimport { Control, Arc, ContinuousRange } from 'solid-parameter-controls';\nimport { render } from 'solid-js/web';\nimport { createSignal } from 'solid-js';\n\nfunction Knob(props) {\n  return _$createComponent(Control, _$mergeProps(props, {\n    get children() {\n      const _el$ = _tmpl$.cloneNode(true);\n\n      _$insert(_el$, _$createComponent(Arc, {\n        x: 0,\n        y: 0,\n        radius: 50,\n        startAngle: 180,\n        endAngle: 250\n      }));\n\n      return _el$;\n    }\n\n  }));\n}\n\nconst range = new ContinuousRange({\n  start: 0,\n  end: 1\n});\n\nfunction ExampleApp() {\n  const [value, setValue] = createSignal(0.25);\n  return [_tmpl$2.cloneNode(true), _$createComponent(Knob, {\n    get value() {\n      return value();\n    },\n\n    onChange: setValue,\n    range: range\n  })];\n}\n\nrender(ExampleApp, document.getElementById('container'));"],"names":[],"sourceRoot":""}